# Progress: SpendSense

## What Works
**Status**: Performance Testing Complete - OpenAI Latency Investigation & Documentation

### Completed âœ…
- âœ… **Performance Testing & Optimization Research Complete**
  - Comprehensive latency investigation for recommendation generation
  - Detailed timing instrumentation implemented (SQL, OpenAI, tone validation, DB save)
  - Bottleneck identified: OpenAI API call (~17s out of ~17s total)
  - Three optimization strategies tested and documented:
    - Model change (gpt-3.5-turbo): 67% faster, most effective
    - Data reduction: No improvement, context size not a factor
    - JSON mode removal: 35% slower, JSON mode is beneficial
  - Documentation created in `docs/performance_testing/`
  - Timing log infrastructure available for future performance testing
  - Decision pending on production optimization approach
- âœ… Memory bank structure created
- âœ… Core documentation established (README, DECISIONS.md, LIMITATIONS.md)
- âœ… Backend project structure initialized
  - FastAPI app skeleton (`backend/app/main.py`)
  - Database setup (`backend/app/database.py`)
  - Directory structure (routers, services, utils, tests)
- âœ… Frontend project structure initialized
  - React 18 + Vite setup
  - Shadcn/ui configured with TailwindCSS
  - Component library initialized (button, card, table, dialog, badge, switch)
  - Project directories (pages, components, lib)
  - API client setup (`frontend/src/lib/api.js`)
- âœ… Git repository initialized
- âœ… Consolidated .gitignore (Python + Node patterns)
- âœ… Environment variable template (example-env.md)
- âœ… Scripts directory created
- âœ… Data directory created with .gitkeep
- âœ… **PR #2: Synthetic Data Generation Complete**
  - Faker dependency added (faker==20.1.0)
  - `scripts/generate_synthetic_data.py` implemented
  - User generation: 75 users (71 customers, 4 operators), 30% consent
  - Account generation: 272 accounts (checking, savings, credit cards, investments)
  - Transaction generation: 15,590 transactions with persona patterns
  - Liability generation: 92 credit card liabilities with varied utilization
  - JSON seed files generated and validated:
    - `data/synthetic_users.json`: 75 records (21KB)
    - `data/synthetic_accounts.json`: 272 records (104KB)
    - `data/synthetic_transactions.json`: 15,590 records (7.9MB)
    - `data/synthetic_liabilities.json`: 92 records (50KB)
  - Persona patterns implemented:
    - High credit card usage users
    - Recurring subscription users
    - Regular savings deposit users
    - Irregular income users
    - Regular biweekly payroll users
  - Data quality verified (valid dates, realistic amounts, proper IDs, correct distributions)
- âœ… **PR #3: Database Schema & SQLAlchemy Models Complete**
  - Database configuration complete (SQLite: `backend/spendsense.db`)
  - All 10 SQLAlchemy models implemented:
    - User model (user_id PK, full_name, email, consent fields, user_type)
    - Account model (account_id PK, user_id FK, type, balances, currency)
    - Transaction model (transaction_id PK, account_id FK, user_id FK, date, amount, merchant, categories, indexes)
    - Liability model (liability_id PK, account_id FK, user_id FK, APR fields, payment info)
    - UserFeature model (feature_id PK, user_id FK, window_days, all behavioral signals, unique constraint)
    - Persona model (persona_id PK, user_id FK, persona_type, confidence_score, unique constraint)
    - Recommendation model (recommendation_id PK, user_id FK, content, status, approval fields, indexes)
    - EvaluationMetric model (metric_id PK, run_id, performance metrics)
    - ConsentLog model (log_id PK, user_id FK, action, timestamp, index)
    - OperatorAction model (action_id PK, operator_id, action_type, recommendation_id FK, user_id FK)
  - Relationships configured (User â†” Accounts, Transactions, Liabilities, etc.)
  - Indexes created for performance (transactions, recommendations, consent_log)
  - Check constraints for enum values (user_type, liability_type, persona_type, content_type, status, action, action_type)
  - Database initialization on FastAPI startup
  - All tables verified with DB Browser for SQLite
- âœ… **PR #4: Pydantic Schemas for Data Validation Complete**
  - Created `backend/app/schemas.py` with all validation schemas
  - User schemas: UserBase, UserCreate, UserResponse (ORM compatible)
  - Account schemas: AccountBase, AccountCreate, AccountResponse (ORM compatible)
  - Transaction schemas: TransactionBase, TransactionCreate, TransactionResponse (with date parsing validator)
  - Liability schemas: LiabilityBase, LiabilityCreate, LiabilityResponse (with date parsing validator)
  - Ingestion schemas: IngestRequest (bulk lists), IngestResponse (status, counts, duration)
  - Feature schemas: UserFeatureResponse (all behavioral signals)
  - Persona schemas: PersonaResponse (persona_type with Literal validation)
  - Recommendation schemas: RecommendationBase, RecommendationCreate, RecommendationResponse, RecommendationApprove, RecommendationOverride, RecommendationReject
  - All schemas use Pydantic v2.5.0 syntax with Literal types for enum validation
  - Date parsing validators for string-to-date conversion
  - ORM compatibility configured with `from_attributes = True`
  - Validation tested and working
- âœ… **PR #5: Data Ingestion API Endpoint Complete**
  - FastAPI app updated with CORS middleware (localhost:5173, localhost:3000)
  - Created `backend/app/routers/ingest.py` with POST `/ingest` endpoint
  - Bulk ingestion implemented for all entity types:
    - Users: Bulk insert with transaction commit
    - Accounts: Bulk insert with transaction commit
    - Transactions: Batched processing (1000 per batch) for performance
    - Liabilities: Bulk insert with transaction commit
  - Error handling with rollback on failure
  - Idempotency handling for duplicate key errors (409 status)
  - Returns IngestResponse with counts and duration in milliseconds
  - Test script created (`scripts/test_ingest.py`)
  - All synthetic data successfully ingested:
    - 75 users loaded
    - 272 accounts loaded
    - 15,590 transactions loaded
    - 92 liabilities loaded
  - Data verified in database using SQLite browser
  - Swagger UI accessible at `/docs`
  - Requests dependency added (requests==2.31.0)
- âœ… **PR #6: Feature Detection Service - Subscription Signals Complete**
  - Created `backend/app/services/feature_detection.py` service file
  - Helper functions implemented:
    - `get_transactions_in_window()` - Queries transactions filtered by date window, ordered by date
    - `get_accounts_by_type()` - Queries accounts filtered by account types
  - Subscription detection implemented:
    - `compute_subscription_signals()` - Main function for subscription pattern detection
    - Groups transactions by merchant_name
    - Filters merchants with â‰¥3 transactions
    - `is_recurring_pattern()` - Detects recurring patterns:
      - Weekly subscriptions (~7 days Â±5 tolerance)
      - Monthly subscriptions (~30 days Â±5 tolerance)
      - Quarterly subscriptions (~90 days Â±5 tolerance)
    - Calculates signals:
      - `recurring_merchants` (count of merchants with recurring patterns)
      - `monthly_recurring_spend` (sum of recurring transactions / months in window)
      - `subscription_spend_share` (recurring spend / total spend, 0-1 ratio)
  - Test script created (`scripts/test_feature_detection.py`)
  - Tests subscription detection for multiple users with both 30-day and 180-day windows
  - Logs results with merchant examples for validation
- âœ… **PR #7: Feature Detection Service - Savings Signals Complete**
  - Added `compute_savings_signals()` function to feature_detection.py
  - Savings account filtering:
    - Filters accounts by type: savings, money market, cash management, HSA
    - Returns zero values if no savings accounts found
  - Net inflow calculation:
    - Separates deposits (amount > 0) and withdrawals (amount < 0) per account
    - Calculates net_inflow per account (deposits + withdrawals)
    - Sums net_inflow across all savings accounts
    - Normalizes to monthly net inflow (net_inflow / months_in_window)
  - Growth rate calculation:
    - Calculates start balance (current balance - net inflow)
    - Computes growth rate per account: (current - start) / start
    - Averages growth rates across all savings accounts
  - Emergency fund calculation:
    - Calculates total savings balance across all savings accounts
    - Estimates monthly expenses from checking account transactions (expenses = amount < 0)
    - Calculates emergency_fund_months: savings_balance / avg_monthly_expenses
    - Handles edge case: sets to 0 if expenses = 0
  - Returns dict with:
    - `net_savings_inflow` (float, monthly average)
    - `savings_growth_rate` (float, 0-1, average across accounts)
    - `emergency_fund_months` (float, months of expenses covered)
  - Error handling: Division by zero protection, logging infrastructure
  - Test script updated to test savings detection for users with and without savings accounts
  - Validates growth rate and emergency fund calculations
- âœ… **PR #8: Feature Detection Service - Credit Signals Complete**
  - Added `compute_credit_signals()` function to feature_detection.py
  - Credit card account querying:
    - Queries credit card accounts using `get_accounts_by_type()` helper
    - Joins with liabilities table via account_id
    - Returns zero/false values if no credit cards found
  - Utilization calculation:
    - Calculates utilization per card: balance_current / balance_limit
    - Computes average utilization across all cards
    - Tracks max utilization (highest single card)
    - Sets utilization flags: â‰¥30%, â‰¥50%, â‰¥80% thresholds
  - Minimum payment detection:
    - Checks if last_payment <= minimum_payment (with $5 tolerance)
    - Sets `minimum_payment_only_flag` if any card matches pattern
  - Interest & overdue detection:
    - Queries transactions for interest charges using `category_detailed` filter
    - Checks `is_overdue` field on liabilities
    - Sets `interest_charges_present` and `any_overdue` flags
  - Returns dict with all 8 credit signals
  - Error handling: Division by zero protection, debug logging
  - Test script updated with comprehensive credit detection tests
  - Tests cover: high/low utilization, minimum payments, overdue accounts
  - Database path fix: Test script uses absolute path to `backend/spendsense.db`
- âœ… **Python Environment Upgrade**: Venv recreated with Python 3.11.9
  - All dependencies reinstalled
  - VS Code settings updated for better import resolution
- âœ… **PR #9: Feature Detection Service - Income Signals Complete**
  - Added `compute_income_signals()` function to feature_detection.py
  - Payroll identification: Filters for ACH deposits, income categories, or payroll merchant names
  - Income pattern analysis: Calculates median pay gap days between paydays
  - Income variability: Computes coefficient of variation (std_dev / mean)
  - Cash flow buffer: Calculates months of expenses covered by checking balance
  - Average monthly income: Sums payroll amounts, normalizes to monthly average
  - Investment account detection: Added `detect_investment_accounts()` function
  - Test script updated with comprehensive income detection tests
- âœ… **PR #10: Feature Computation Endpoint & Batch Script Complete**
  - Created `compute_all_features()` function that combines all 4 signal types
  - Features router: POST `/compute/{user_id}` endpoint with window_days parameter
  - Profile router: GET `/{user_id}` endpoint returns features and personas
  - Batch computation script processes all users for both 30d and 180d windows
  - Successfully computed and saved 142 feature records (71 users Ã— 2 windows)
  - Average computation time: 0.013 seconds per user
- âœ… **PR #11: Frontend - Project Setup & Basic Routing Complete**
  - Vite configuration: Port 5173, `@src` path alias configured
  - API client (`frontend/src/lib/api.js`): Axios instance with interceptors
  - API service functions (`frontend/src/lib/apiService.js`): All 12 functions implemented
  - React Router setup: BrowserRouter with all routes configured
  - Layout component: Navigation header with active state styling
  - Page placeholders: All 5 pages created (OperatorDashboard, OperatorUserList, OperatorUserDetail, OperatorApprovalQueue, UserDashboard)
  - Configuration files: vite.config.js, tailwind.config.js, jsconfig.json updated
- âœ… **PR #12: Frontend - Operator Dashboard (Metrics & Charts) Complete**
  - Dashboard data fetching: useState/useEffect hooks, API integration, error handling
  - MetricsCard component: Reusable card component with title, value, subtitle
  - UI components: Skeleton and Alert components created
  - Dashboard layout: Responsive grid with 4 metrics cards (Total Users, Users with Consent, Pending Approvals, Avg Latency)
  - Charts: Persona Distribution and Recommendation Status bar charts using Recharts
  - Loading states: Skeleton placeholders for cards and charts
  - Error states: Alert component with retry functionality
  - Fast Refresh fixes: Removed unnecessary exports, updated all imports to `@src` alias
- âœ… **PR #13 Complete: Frontend - Operator User List Page & Backend Endpoints (all 61 tasks finished)**
  - Frontend components:
    - UserTable component: Displays users with name, email, persona (30d), consent status, actions
    - UserFilters component: Filter by user type and consent status using styled select dropdowns
    - Pagination component: Previous/next buttons, page numbers (5 at a time), disabled states
    - UserTableSkeleton component: Loading skeleton matching table structure
  - Frontend enums system:
    - Created `frontend/src/constants/enums.js` with UserType, ConsentStatus, ConsentAction enums
    - Helper functions: getConsentStatusDisplay(), getUserTypeDisplay()
    - Used throughout frontend for consistency
  - OperatorUserList page:
    - Data fetching with useState/useEffect, pagination, filters
    - Search functionality with debouncing (300ms)
    - Local filtering by name or email
    - Loading states with skeleton
    - Error states with alert and retry button
    - Empty state handling
    - Responsive layout
  - Backend endpoints:
    - GET /users endpoint: Pagination (limit/offset), filters (user_type, consent_status), includes 30d personas
    - GET /operator/dashboard endpoint: Total users, users with consent, persona distribution, recommendation status breakdown, average latency
  - Router registration: Both routers registered in main.py
  - All components tested and working
- âœ… **PR #14 Complete: Frontend - Operator User Detail Page (all 52 implementation tasks finished)**
  - Backend endpoints added:
    - GET /users/{user_id}: Returns user with personas for both 30d and 180d windows
    - GET /operator/users/{user_id}/signals: Returns detailed signals with 30d_signals and 180d_signals objects
      - Subscriptions: recurring_merchants (array), monthly_spend, spend_share
      - Savings: net_inflow, growth_rate, emergency_fund_months
      - Credit: cards array with last_four, utilization, balance, limit
      - Income: payroll_detected, avg_monthly, frequency
  - Frontend components created:
    - UserInfoCard: User information display with badges for consent status
    - PersonaDisplay: Persona visualization with large badge, confidence score, assigned date, color coding
    - SignalDisplay: Comprehensive signal visualization with 4 signal type views (subscriptions, savings, credit, income)
    - Progress component: Shadcn-style progress bar for visualizations
  - OperatorUserDetail page:
    - Two-column responsive layout
    - Left column: UserInfoCard, PersonaDisplay (30d), PersonaDisplay (180d)
    - Right column: Tab navigation for signal types, SignalDisplay for 30d and 180d windows
    - Recommendations section: Fetches and displays recommendations with status badges
    - Back navigation button
    - Loading skeletons for all sections
    - Error states with retry functionality
    - Parallel data fetching for user, profile, signals, and recommendations
- âœ… **PR #15 Complete: Persona Assignment Service (all 29 tasks finished)**
  - Persona assignment service (`backend/app/services/persona_assignment.py`):
    - 5 persona check functions: high_utilization, variable_income, subscription_heavy, savings_builder, wealth_builder
    - Helper functions: get_total_savings_balance(), has_overdraft_or_late_fees()
    - Priority-based assignment logic: wealth_builder (1.0) â†’ high_utilization (0.95/0.8) â†’ savings_builder (0.7) â†’ variable_income (0.6) â†’ subscription_heavy (0.5)
    - Reasoning dictionary: matched_criteria, feature_values, timestamp, priority, all_matched_personas
    - Database persistence: create_or_update_persona() with JSON-serialized reasoning
    - Main function: assign_and_save_persona() combines assignment and persistence
  - Test script (`scripts/test_persona_assignment.py`):
    - Tests individual persona check functions
    - Tests persona assignment logic
    - Tests saving personas to database
    - Verifies persona records and distribution
- âœ… **PR #16 Complete: Persona Assignment Endpoint & Batch Script (all 29 tasks finished)**
  - Personas router (`backend/app/routers/personas.py`):
    - POST `/{user_id}/assign` endpoint: Assigns persona for user with optional window_days parameter
    - GET `/{user_id}` endpoint: Retrieves personas with optional window filter
    - Error handling: 404 (user not found), 400 (features not computed), 500 (server error)
  - Router registration: Personas router registered in main.py
  - Batch assignment script (`scripts/assign_all_personas.py`):
    - Processes all users, assigns personas for both 30-day and 180-day windows
    - Progress reporting and summary statistics
    - Validation warnings for missing persona types
  - Fallback behavior: When no persona matches, assigns 'savings_builder' with low confidence (0.1 if no features, 0.2 if features exist but no match)
  - Successfully assigned personas to 71 users (142 persona records: 71 users Ã— 2 windows)
  - Note: Synthetic data variance enhancement needed - some persona types (wealth_builder, variable_income) not well represented in current test data
- âœ… **PR #17 Complete: OpenAI Integration Setup & Prompt Templates (all 50 tasks finished)**
  - OpenAI dependencies: Added `openai==1.3.5` to requirements.txt, installed SDK, API key configured
  - Prompts directory: Created `backend/app/prompts/` with 5 self-contained persona-specific prompts
  - Prompt design: Following "just right" calibration guide - lean (~42-52 lines), self-contained, principle-based
  - Persona prompts created:
    - `high_utilization.txt`: Debt paydown, utilization impact, payment automation, balance transfers, interest calculation
    - `variable_income.txt`: Percent-based budgeting, emergency funds, income smoothing, cash flow buffers, expense management
    - `subscription_heavy.txt`: Subscription audits, cancellation tactics, free alternatives, bill alerts, annual vs monthly comparisons
    - `savings_builder.txt`: Goal setting, automation, high-yield accounts, CDs, progress tracking
    - `wealth_builder.txt`: Tax-advantaged investing, asset allocation, retirement planning, estate planning, charitable giving (educational only)
  - Prompt structure: Role & Context, Core Principles, Response Framework (5 steps), Guidelines (with topic lists), Output Format
  - Prompt loader utility: `backend/app/utils/prompt_loader.py` with caching, error handling, validation
- âœ… **PR #18 Complete: Recommendation Engine Service - Context Building (all 34 tasks finished)**
  - Recommendation engine service (`backend/app/services/recommendation_engine.py`):
    - OpenAI client setup function ready for PR #19
    - User context builder (`build_user_context()`) that queries all necessary user data:
      - User, UserFeature, Persona records
      - Top 5 accounts by balance (with masked names)
      - Last 10 transactions (last 30 days)
      - High utilization credit cards (when applicable)
      - Recurring merchants list (when applicable)
      - Savings account growth info (when applicable)
    - Context structure includes all behavioral signals, accounts, transactions, and persona-specific data
    - Context validation function (`validate_context()`) with comprehensive checks
    - All float values rounded to 2 decimal places
    - Token-efficient design (limits data to essential items)
  - Test script (`scripts/test_context_builder.py`):
    - Tests multiple users with comprehensive validation
    - Token count estimation (all under 2000 token target)
    - Data quality checks
  - Test results: All 5 users tested successfully, context validation passed, token counts 583-764 tokens
- âœ… **PR #19 Complete: Recommendation Engine Service - OpenAI Integration (all 26 tasks finished)**
  - OpenAI API integration complete:
    - `generate_recommendations_via_openai()` function implemented
    - OpenAI chat completions API calls (gpt-4o-mini, temperature 0.75)
    - Exponential backoff retry logic for rate limits
    - Comprehensive error handling (rate limits, API key, model errors, JSON parsing)
    - Response parsing and validation
    - Token usage tracking and cost calculation
    - Token info in metadata for review (stripped before DB save)
  - Prompt improvements:
    - Added LANGUAGE STYLE section to all 5 prompts with explicit empowering language requirements
    - Temperature increased to 0.75 for more natural variation
    - All recommendations now pass quality checks (empowering tone validated)
  - Test script (`scripts/test_openai_generation.py`):
    - Tests all 5 persona types
    - Validates response structure, quality, and tone
    - Saves output to JSON file for review
  - Test results: All 3 tested persona types passed, empowering language verified
- âœ… **PR #20 Complete: Guardrails Service - Tone & Consent Validation (all 38 tasks finished)**
  - Guardrails service (`backend/app/services/guardrails.py`):
    - `validate_tone()` function: Returns structured dict with `is_valid` and `validation_warnings` array
      - Critical warnings: Forbidden phrases (severity="critical", type="forbidden_phrase") â†’ RED in operator UI
      - Notable warnings: Lacks empowering language (severity="notable", type="lacks_empowering_language") â†’ YELLOW in operator UI
      - Empty array when valid, populated array with warnings when invalid
    - `check_consent()` function: Checks user consent status with logging
    - Eligibility functions: `check_income_eligibility()`, `check_credit_eligibility()`, `check_account_exists()`
    - `filter_partner_offers()` function: Filters offers based on eligibility requirements
    - `append_disclosure()` function: Appends mandatory disclosure to content
    - `MANDATORY_DISCLOSURE` constant defined
  - Test script (`scripts/test_guardrails.py`):
    - Tests tone validation with valid content, forbidden phrases, lacks empowering language, both issues
    - Tests consent checking with consented/non-consented/non-existent users
    - Tests eligibility checks (income, credit, account existence)
    - Tests partner offer filtering
    - Tests mandatory disclosure appending
  - Test results: All tests passing, all 38 tasks completed
  - Key design: All recommendations persisted regardless of warnings - operator reviews and decides
- âœ… **PR #21 Complete: Recommendation Generation Endpoint (all 44 tasks finished)**
  - Recommendations router (`backend/app/routers/recommendations.py`):
    - POST `/recommendations/generate/{user_id}` endpoint with full workflow
    - Query parameters: `window_days` (default: 30), `force_regenerate` (default: False)
    - User validation (404 if not found), consent check (403 if not consented)
    - Existing recommendations check (returns cached if exists and not force_regenerate)
    - Persona validation (400 if no persona assigned)
    - Context building and validation
    - OpenAI integration for recommendation generation
    - Tone validation for each recommendation with warnings stored in metadata
    - Database persistence with status='pending_approval' for all recommendations
    - Mandatory disclosure appended to content
    - Validation warnings stored in metadata_json (empty array for valid, populated for invalid)
    - Token usage and cost data stripped from metadata before saving (logging only)
    - Status codes: 200 for cached results, 201 for newly created
    - Comprehensive error handling with rollback on failures
  - Router registration: Recommendations router registered in main.py
  - Metadata design: Saves metadata (including validation_warnings) but excludes token_usage and estimated_cost_usd (used for logging/review only)
  - All recommendations persisted regardless of warnings for operator review
  - Tested and verified via Swagger UI
- âœ… **PR #22 Complete: Get Recommendations Endpoint (all 23 tasks finished)**
  - Recommendations router (`backend/app/routers/recommendations.py`):
    - GET `/recommendations/{user_id}` endpoint implemented
    - Query parameters: `status` (optional, filters by status), `window_days` (optional, filters by window_days)
    - User validation (404 if not found)
    - Query logic: Filters by user_id, optional status, optional window_days
    - Ordering: By generated_at descending (newest first)
    - Limit: 50 recommendations (pagination ready for future)
    - Response format: Returns recommendations list with all required fields (recommendation_id, title, content, rationale, status, persona_type, generated_at, approved_by, approved_at) and total count
    - Access control: Removed premature access control logic (will be implemented when authentication is added)
    - Error handling: 404 for user not found, 500 for database errors, comprehensive logging
    - Test script created (`scripts/test_get_recommendations.py`) for testing various filter combinations
  - Note: Access control removed - endpoint returns all recommendations when no status filter provided (authentication needed to determine requester identity)
- âœ… **PR #23 Complete: Approve Recommendation Endpoint (all 26 tasks finished)**
  - Recommendations router (`backend/app/routers/recommendations.py`):
    - POST `/recommendations/{recommendation_id}/approve` endpoint implemented
    - Accepts recommendation_id as path parameter
    - Accepts RecommendationApprove schema in body (operator_id, optional notes)
    - Validation: 404 if recommendation not found, 400 if already approved, 400 if status is 'rejected'
    - Updates recommendation: Sets status='approved', approved_by=operator_id, approved_at=current timestamp
    - Creates OperatorAction record for audit trail (action_type='approve', includes operator_id, recommendation_id, user_id, reason)
    - Returns updated recommendation with all fields (recommendation_id, title, content, rationale, status, persona_type, generated_at, approved_by, approved_at)
    - Error handling: 404 for not found, 400 for invalid state transitions, 500 for database errors
    - Comprehensive logging for all approve actions
  - Test script created (`scripts/test_approve_recommendation.py`) for testing approval workflow
  - All 26 tasks completed
- âœ… **PR #24 Complete: Override & Reject Endpoints (all 39 tasks finished)**
  - Recommendations router (`backend/app/routers/recommendations.py`):
    - POST `/recommendations/{recommendation_id}/override` endpoint implemented
    - POST `/recommendations/{recommendation_id}/reject` endpoint implemented
  - Schema updates:
    - Updated `RecommendationOverride` schema to make `new_title` and `new_content` optional
  - Override endpoint features:
    - Accepts recommendation_id as path parameter
    - Accepts RecommendationOverride schema (operator_id, optional new_title, optional new_content, required reason)
    - Validation: 404 if not found, 400 if neither new_title nor new_content provided
    - Stores original content in JSON format (original_title, original_content, overridden_at timestamp)
    - Updates recommendation: Sets status='overridden', updates title/content if provided, appends disclosure, validates tone
    - Tone validation: Rejects new content with critical warnings (forbidden phrases) â†’ 400 error
    - Creates OperatorAction record with action_type='override'
    - Returns updated recommendation with original_content and override_reason
  - Reject endpoint features:
    - Accepts recommendation_id as path parameter
    - Accepts RecommendationReject schema (operator_id, required reason)
    - Validation: 404 if not found, 400 if already approved (can't reject approved recs)
    - Updates recommendation: Sets status='rejected', stores rejection reason in metadata_json
    - Metadata includes: rejection_reason, rejected_by, rejected_at
    - Creates OperatorAction record with action_type='reject'
    - Returns updated recommendation with rejection metadata
  - Error handling: 404 for not found, 400 for validation errors, 500 for database errors
  - Comprehensive logging for all override and reject actions
  - Test script created (`scripts/test_override_reject.py`) with 8 test cases covering:
    - Override with new title and content
    - Override with only new title
    - Override with only new content
    - Validation tests (neither title nor content, tone validation)
    - Reject pending recommendation
    - Reject validation (can't reject approved)
    - Non-existent recommendation tests
  - All 39 tasks completed
- âœ… **PR #25 Complete: Bulk Approve Endpoint (all 21 tasks finished)**
  - Recommendations router (`backend/app/routers/recommendations.py`):
    - POST `/recommendations/bulk-approve` endpoint implemented
    - Accepts BulkApproveRequest schema (operator_id, recommendation_ids array)
    - Processes each recommendation individually with error handling
    - Validates each recommendation exists and is in 'pending_approval' status
    - Updates recommendations: Sets status='approved', approved_by=operator_id, approved_at=current timestamp
    - Creates OperatorAction records for audit trail
    - Batch commit: All changes committed in single transaction
    - Returns BulkApproveResponse with approved count, failed count, and error messages
    - Error handling: Individual recommendation errors don't fail entire batch
    - Status codes: 200 if any succeeded, 400 if all failed
    - Comprehensive logging for bulk operations
  - Test script created (`scripts/test_bulk_approve.py`) for testing bulk approval workflow
  - All 21 tasks completed
- âœ… **PR #26 Complete: Frontend - Approval Queue Page (all 74 tasks finished)**
  - Backend endpoint added:
    - GET `/operator/review` endpoint: Fetches all recommendations where status != 'approved'
    - Optional status filter (pending_approval, overridden, rejected)
    - Orders by generated_at ascending (oldest first, queue order)
    - Includes user information via JOIN for efficient querying
    - Returns recommendations with all relevant fields and total count
  - Frontend components created:
    - RecommendationCard component: Displays recommendation with checkbox, user info, persona badge, content/rationale previews, action buttons (Approve, Reject, Override)
    - Checkbox UI component: Created using Radix UI (@radix-ui/react-checkbox)
  - API service functions added:
    - `overrideRecommendation()` - Override a recommendation with new content
    - `rejectRecommendation()` - Reject a recommendation with reason
  - OperatorApprovalQueue page:
    - Data fetching with useState/useEffect, auto-refresh every 30 seconds
    - State management: recommendations, selectedIds (Set), loading, error, statusFilter, actionLoading
    - Bulk selection: Select all checkbox, individual checkboxes, selected count display
    - Bulk approve button: Disabled when no selection, loading state, success/error messaging
    - Individual approve: Per-recommendation approve with loading state, removes from queue on success
    - Override dialog: Shadcn Dialog with form fields (new title optional, new content optional, reason required), validation, tone validation
    - Reject dialog: Shadcn Dialog with reason field (required), removes from queue on success
    - Page layout: Header with title and refresh button, toolbar with select all, count, filter dropdown, bulk approve button
    - Status filter: Dropdown for pending_approval, overridden, rejected
    - Loading states: Skeleton cards while loading
    - Error states: Alert component with retry functionality
    - Success/error messages: Auto-dismiss after 5 seconds
    - Empty state: Message when no recommendations in queue
    - Auto-refresh: 30-second interval with cleanup on unmount
  - Server concurrency optimizations:
    - Implemented uvicorn workers (4 workers) for concurrent request handling
    - Enabled SQLite WAL (Write-Ahead Logging) mode for concurrent reads during writes
    - Fixed hanging issue: User list no longer hangs when recommendation generation is running
    - Documentation updated: README.md, techContext.md, DECISIONS.md, LIMITATIONS.md, FRAMEWORK_CONCURRENCY_COMPARISON.md
  - Markdown rendering for recommendations:
    - Installed react-markdown package for rendering Markdown in recommendation content
    - Updated RecommendationCard component to use ReactMarkdown for content and rationale previews
    - Updated OperatorUserDetail page to use ReactMarkdown for recommendation content display
    - Added type checking to ensure ReactMarkdown always receives string values
    - Updated truncateText helper to validate input is a string before processing
    - Markdown syntax (bold, italic, etc.) renders correctly in both approval queue and user detail pages
  - Expandable content functionality:
    - Added expandable content to RecommendationCard component with independent state for content and rationale
    - Added expandable content to OperatorUserDetail recommendation cards
    - "Show more"/"Show less" buttons appear only when content/rationale exceeds 150 characters
    - Full content expands inline with ReactMarkdown rendering
    - Both content and rationale can be expanded independently in RecommendationCard
    - Styled expand/collapse buttons with blue hover states
  - Form validation improvements:
    - Added client-side validation for override and reject dialogs
    - Validation errors display as red italic text below input fields
    - Errors persist until user types in the field
    - Modal stays open and prevents API call if validation fails
  - All 74 tasks completed
- âœ… **PR #27 Complete: Frontend - User Dashboard & Consent (all 44 tasks finished)**
  - Backend consent endpoints:
    - Created `backend/app/routers/consent.py` router
    - POST `/consent` endpoint: Updates user consent status (grant/revoke), creates ConsentLog entries
    - GET `/consent/{user_id}` endpoint: Returns consent status, timestamps, and full history
    - Consent schemas added: ConsentRequest, ConsentHistoryItem, ConsentResponse
    - Router registered in main.py
    - Error handling and logging implemented
  - Frontend components:
    - ConsentToggle component: Switch with confirmation dialogs, status badge, timestamp display
    - UserRecommendationCard component: Read-only recommendation display with markdown, expandable content
  - UserDashboard page:
    - Parallel data fetching (user, consent, recommendations)
    - Consent management with grant/revoke flows
    - Recommendations display with expandable content and markdown rendering
    - Empty states for no consent and no recommendations
    - Error handling and loading states
    - Responsive layout
  - All 44 tasks completed (7 backend + 37 frontend)
- âœ… **PR #28 Complete: Evaluation Script - Metrics Computation (all 54 tasks finished)**
- âœ… **PR #42 Complete: Hybrid Recommendation Engine + Product Data Normalization (all 119 tasks finished)**
  - Hybrid recommendation engine:
    - Updated schemas: ProductOfferBase, ProductOfferResponse, RecommendationResponse with product fields
    - Created `generate_combined_recommendations()` function combining educational and product recommendations
    - Educational recommendations limited to 3 only if product recommendations found
    - Updated database models: Added product_id column, made content nullable
    - Updated API endpoints: POST and GET recommendations endpoints handle both content types
    - Test script: `scripts/test_hybrid_recommendations.py` with comprehensive coverage
  - Product catalog data normalization:
    - Regenerated catalog with ~150 products (batch generation: 5 batches of ~30 products)
    - Applied deterministic eligibility rules post-LLM generation:
      - `requires_no_existing_savings` only TRUE for HYSA
      - `requires_no_existing_investment` only TRUE for investment products
      - Numeric eligibility fields set deterministically based on category
    - Database schema updates: Added "loan" product_type, made content nullable
    - Migration consolidation: Added `apply_migrations()` to database.py, removed temporary scripts
- âœ… **PR #40 Complete: Product Matching Service (all 91 tasks finished)**
  - Created `backend/app/services/product_matcher.py` service file
  - Helper functions: `get_account_types()`, `has_hysa()`, `has_investment_account()`
  - Relevance scoring: `calculate_relevance_score()` with category-specific rules for all 5 product categories
  - Rationale generation: `generate_product_rationale()` with personalized explanations citing specific user data
  - Main matching function: `match_products()` - Filters by persona, scores products, generates rationales, applies eligibility filtering, returns top 3 eligible products
  - Test script: `scripts/test_product_matching.py` with comprehensive coverage for all 5 personas and edge cases
  - All 91 tasks completed (service setup, scoring logic, rationale generation, main function, helper functions, testing)
- âœ… **PR #41 Complete: Enhanced Guardrails - Product Eligibility (all 66 tasks finished)**
  - Updated `backend/app/services/guardrails.py` with product eligibility checking:
    - Added `check_product_eligibility()` function that checks income, utilization, existing accounts, category-specific rules
    - Returns tuple of (is_eligible: bool, reason: str) with comprehensive logging
    - Added `filter_eligible_products()` function for batch filtering product matches
  - Updated `backend/app/services/product_matcher.py` to integrate eligibility filtering
  - Created test script (`scripts/test_product_eligibility.py`) with comprehensive coverage
  - All 66 tasks completed (eligibility checker, batch filtering, integration, testing)
- âœ… **PR #38 Complete: Database Schema & Product Catalog Generation (all 64 tasks finished)**
- âœ… **PR #39 Complete: Product Ingestion via API (all tasks finished)**
  - Added products support to `/ingest/` endpoint for consistency
  - Created product schemas (ProductCreate, ProductResponse)
  - Updated ingestion endpoint to handle products with JSON conversion
  - Created `scripts/test_ingest_products.py` for API-based ingestion
  - Removed direct seeding scripts (seed_product_catalog.py, test_product_seeding.py)
  - Products now follow same ingestion pattern as all other data
  - Created `ProductOffer` model in `backend/app/models.py` with all required fields (product_id, product_name, product_type, category, persona_targets, eligibility criteria, content fields, business fields, timestamps, indexes)
  - Product generation script (`scripts/generate_product_catalog.py`) enhanced and tested:
    - Loads `.env` from backend folder automatically
    - Uses OpenAI GPT-4o to generate 20-25 realistic financial products
    - Includes all 5 personas, eligibility criteria guidelines, standard disclosure template
    - Validation and enhancement functions add all required metadata
  - Generated product catalog (`data/product_catalog.json`):
    - 21 products successfully generated (within 20-25 target)
    - Persona distribution: high_utilization (5), variable_income (7), subscription_heavy (4), savings_builder (6), wealth_builder (7)
    - All products include disclosures, 3-5 benefits, realistic APY/fee values, appropriate eligibility criteria
    - Product names realistic (Chase, Marcus, YNAB, Rocket Money, etc.)
  - Documentation:
    - Added product catalog generation instructions to README.md
    - Created `docs/PRODUCT_SCHEMA.md` with complete schema documentation
    - Updated project structure in README.md
  - Test script created (`scripts/test_product_offer_model.py`) for model validation
  - Created `scripts/evaluate.py` evaluation script
  - Coverage metrics: `compute_coverage_metrics()` - Calculates percentage of users with personas assigned
  - Explainability metrics: `compute_explainability_metrics()` - Calculates percentage of recommendations with rationale
  - Latency metrics: `compute_latency_metrics()` - Calculates average and p95 latency using numpy.percentile()
  - Auditability metrics: `compute_auditability_metrics()` - Verifies all recommendations have decision traces (100%)
  - Persona distribution: `get_persona_distribution()` - Groups personas by type for 30d and 180d windows
  - Recommendation status breakdown: `get_recommendation_status_breakdown()` - Groups recommendations by status
  - Main evaluation function: `run_evaluation()` - Generates unique run_id, calls all metric functions, combines results, prints formatted output
  - Database persistence: `save_evaluation_metrics()` - Saves all metrics to evaluation_metrics table with JSON details
  - Dependencies added: pandas==2.1.4, numpy==1.26.2 to requirements.txt and installed in venv
  - Script tested: Successfully runs, computes all metrics, saves to database, prints formatted output
  - All 54 tasks completed

### In Progress
- ðŸ”„ **Product Catalog Feature (PR #38-45)** - PR #38-42 Complete, PR #43-45 Next
  - âœ… PR #38: Database schema, product generation, catalog created (21 products)
  - âœ… PR #39: Product ingestion via API endpoint (consistent with other data)
  - âœ… PR #40: Product matching service (persona + signal based scoring, rationale generation, top 3 products)
  - âœ… PR #41: Eligibility filtering (income, utilization, existing accounts, category-specific rules)
  - âœ… PR #42: Hybrid recommendation engine + product data normalization (combined educational + product recommendations, ~150 products with deterministic eligibility rules)
  - ðŸ”„ PR #43-45: Frontend display, product management API, unit tests
- ðŸ”„ **Article Catalog Feature (PR #46-51)** - Planning complete, ready for implementation
  - Comprehensive 275+ task breakdown created in tasks-12.md
  - 6 PRs planned: Database schema + article generation, article seeding + vector population, article matching service, hybrid engine integration, frontend display, unit tests & documentation
  - Vector-based matching using Pinecone + OpenAI embeddings
  - Real-time similarity search (<300ms for 2-3 recs)
  - 50 LLM-generated articles for MVP (10 per persona) - will replace with real articles later
  - Expected timeline: 2.5-3.5 hours total
  - Expected cost: ~$0.30-0.50 for one-time LLM-generated article catalog

### Not Started
- â³ Parquet export & S3 integration (PR #29) - **PAUSED: No AWS access**
- â³ Evaluation API endpoints (PR #30)
- â³ Redis caching layer (PR #31)
- â³ PostgreSQL migration (PR #32) - **PAUSED: No AWS access**
- â³ Scale synthetic data to 500-1,000 users (PR #33)
- â³ Vector DB integration with Pinecone (PR #34-37)
- â³ AWS deployment - **PAUSED: No AWS access**

## What's Left to Build

### PR #14: Operator User Detail Page âœ… Complete
- [x] Build user detail page with signals and personas
- [x] Display user info, personas (30d and 180d), and signal breakdowns
- [x] Add tab navigation for signal types

### PR #15: Persona Assignment Engine âœ… Complete
- [x] Implement rules-based persona assignment logic
- [x] Create persona prioritization system
- [x] Test persona assignment with computed features

### PR #16: Persona Assignment Endpoint & Batch Script âœ… Complete
- [x] Add persona assignment API endpoint (POST /personas/{user_id}/assign)
- [x] Add persona retrieval API endpoint (GET /personas/{user_id})
- [x] Create batch assignment script for all users
- [x] Fallback persona behavior: Use 'savings_builder' with low confidence when no persona matches
- [x] Assign personas to all 71 users (142 records: 30d and 180d windows)

### Day 1 Deliverables (MVP)
- [x] SQLite database schema (10 tables) - **PR #3 Complete**
- [x] POST `/ingest` endpoint working - **PR #5 Complete**
- [x] All behavioral signals computed (30d and 180d windows) - **PR #6-9 Complete**
- [x] Feature computation endpoint and batch script - **PR #10 Complete**
- [x] React UI components built (operator dashboard, user list) - **PR #12, #13 Complete**
- [x] Backend endpoints for users and dashboard - **PR #13 Complete**
- [ ] Full integration testing possible via UI (pending user detail page)

### Day 2 Deliverables (MVP)
- [x] All 5 personas assigned with prioritization (PR #15, #16 complete)
- [x] AI recommendation generation working (PR #19 complete - OpenAI integration functional)
- [x] Guardrails enforced (consent, tone, eligibility) - **PR #20 Complete**
- [x] Approval workflow API endpoints - **PR #23 Complete (approve), PR #24 Complete (override & reject), PR #25 Complete (bulk approve)**
- [x] Recommendations visible and testable in UI - **PR #26 Complete (approval queue page)**
- [x] Approval workflow functional in UI (approve/reject/override) - **PR #26 Complete**
- [x] Evaluation script outputs metrics - **PR #28 Complete**
- [ ] Parquet export to S3 (PR #29)
- [ ] Metrics displayed in operator dashboard (PR #31)

### Day 3+ (Performance Optimization & Deployment)
- [ ] Parquet export & S3 integration (PR #29)
- [ ] Evaluation API endpoints (PR #30)
- [ ] Redis caching layer (PR #31) - **Quick win for repeated queries**
- [ ] PostgreSQL migration (PR #32) - **Production-grade database**
- [ ] Scale synthetic data to 500-1,000 users (PR #33) - **Prerequisite for vector DB**
- [ ] Vector DB integration with Pinecone (PR #34-37) - **Sub-1s latency showcase**
  - Pinecone setup & embedding infrastructure
  - Batch embedding job (populate vector DB)
  - Vector search implementation
  - Hybrid recommendation engine (vector DB + OpenAI fallback)
- [ ] FastAPI deployed to AWS Lambda
- [ ] Frontend deployed (Vercel/Netlify/S3+CloudFront)
- [ ] 10 unit tests passing
- [ ] Documentation complete (README, decision log, limitations)

## Current Status

### Backend
- **Status**: Feature detection complete, persona assignment service and endpoints complete, API endpoints for users and dashboard working
- **Completed**: FastAPI app, database setup, all 10 models, all Pydantic schemas, ingestion endpoint, all 4 signal detection types (subscription, savings, credit, income), feature computation function, features router, profile router, users router, operator router, personas router, batch computation script, persona assignment service with all check functions and assignment logic, batch persona assignment script
- **Next**: AI recommendation generation (PR #17+)
- **Priority**: Create OpenAI integration with 5 persona-specific endpoints

### Frontend
- **Status**: Operator Dashboard, User List, User Detail, Approval Queue, and User Dashboard complete
- **Completed**: React 18 + Vite, Shadcn/ui configured, TailwindCSS setup, API client, API service functions, React Router setup, Layout component, Operator Dashboard with metrics cards and charts, Operator User List with table, filters, pagination, search, Operator User Detail with two-column layout, tabs, signal displays, recommendations section, Operator Approval Queue with bulk selection, individual actions, override/reject dialogs, User Dashboard with consent toggle and recommendation display, ConsentToggle component, UserRecommendationCard component, RecommendationCard component, Checkbox component, UserInfoCard, PersonaDisplay, SignalDisplay components, Progress component, loading/error states, responsive layout, enum system for constants
- **Next**: Evaluation system and AWS deployment
- **Priority**: Evaluation system and AWS deployment

### Database
- **Status**: âœ… Complete - All models implemented, data loaded, features computed, personas assigned, product catalog schema ready
- **Completed**: SQLAlchemy configuration, all 11 models (including ProductOffer), relationships, indexes, constraints, initialization
- **Database File**: `backend/spendsense.db` (verified with DB Browser)
- **Data Loaded**: 75 users, 272 accounts, 15,590 transactions, 92 liabilities
- **Features Computed**: 142 feature records (71 users Ã— 2 windows: 30d and 180d)
- **Personas Assigned**: 142 persona records (71 users Ã— 2 windows: 30d and 180d)
- **Product Catalog**: Schema ready, 21 products generated in JSON, ingested via `/ingest/` endpoint
- **Product Matching**: Service complete (`backend/app/services/product_matcher.py`), matches products to users based on persona and signals
- **Product Eligibility**: Service complete (`backend/app/services/guardrails.py`), filters products by eligibility criteria
- **Next**: Hybrid recommendation engine (PR #42)

### Data Generation
- **Status**: âœ… Complete and tested
- **Completed**: All 4 JSON seed files generated with realistic patterns
- **Output**: âœ… Ingested into database
- **Quality**: Validated (dates, amounts, IDs, distributions correct)

### Data Validation
- **Status**: âœ… Complete - All Pydantic schemas implemented
- **Completed**: All 31 schema tasks, validation tested, ORM compatibility configured
- **Usage**: âœ… Used successfully in ingestion endpoint

### Data Ingestion
- **Status**: âœ… Complete - Endpoint functional and tested
- **Completed**: POST `/ingest` endpoint, bulk insertion, batching, error handling, idempotency
- **Data Loaded**: All synthetic data successfully ingested
- **Usage**: âœ… Data ready for feature detection

### Feature Detection
- **Status**: âœ… All Signal Types Complete - Service module complete with computation endpoints
- **Completed**: Helper functions, all 4 signal detection types (subscription, savings, credit, income), investment account detection, feature computation function, features router, profile router, batch computation script
- **Service File**: `backend/app/services/feature_detection.py`
- **Routers**: `backend/app/routers/features.py`, `backend/app/routers/profile.py`
- **Test Script**: `scripts/test_feature_detection.py` (tests all 4 signal types)
- **Batch Script**: `scripts/compute_all_features.py` (computes features for all users)
- **Features Computed**: 142 records (71 users Ã— 2 windows)
- **Next**: AI recommendation generation (PR #17+)

### Persona Assignment
- **Status**: âœ… Complete - Service, API endpoints, and batch script implemented
- **Completed**: Persona assignment service with all 5 check functions, priority-based assignment logic, reasoning dictionary generation, database persistence, API endpoints (POST /personas/{user_id}/assign, GET /personas/{user_id}), batch assignment script
- **Service File**: `backend/app/services/persona_assignment.py`
- **Router File**: `backend/app/routers/personas.py`
- **Test Script**: `scripts/test_persona_assignment.py` (tests assignment logic and database persistence)
- **Batch Script**: `scripts/assign_all_personas.py` (assigns personas to all users)
- **Personas Assigned**: 142 records (71 users Ã— 2 windows: 30d and 180d)
- **Distribution**: 30d - 44 high_utilization, 10 subscription_heavy, 1 savings_builder (with fallback assignments tracked separately); 180d - 44 high_utilization, 19 subscription_heavy (with fallback assignments tracked separately)
- **Note**: Synthetic data variance enhancement needed - wealth_builder and variable_income personas not well represented in current test data
- **Next**: AI recommendation generation (PR #17+)

### AI Integration
- **Status**: âœ… Complete - OpenAI SDK installed, prompt templates complete, context building complete, OpenAI API integration complete, recommendation generation endpoint complete, performance testing complete
- **Completed**: OpenAI SDK (v2.7.1, upgraded from 1.3.5) installed, API key configured, 5 persona-specific prompts created with empowering language requirements, prompt loader utility with caching, recommendation engine service with context building and OpenAI API integration, recommendation generation endpoint with full workflow
- **Performance Testing**: Comprehensive latency investigation completed
  - Identified OpenAI API call as bottleneck (~17s average)
  - Tested optimization strategies (model change, data reduction, JSON mode removal)
  - Model choice (gpt-4o-mini vs gpt-3.5-turbo) is the primary performance factor
  - Documentation: `docs/performance_testing/OPENAI_LATENCY_TESTING.md` and `recommendation_timing_results.md`
  - Timing log infrastructure available (commented out) in `backend/app/routers/recommendations.py`
- **Prompt Files**: `backend/app/prompts/` directory with 5 self-contained prompts (high_utilization, variable_income, subscription_heavy, savings_builder, wealth_builder)
  - All prompts include LANGUAGE STYLE section with explicit empowering language requirements
  - Temperature set to 0.75 for natural variation
- **Prompt Loader**: `backend/app/utils/prompt_loader.py` with `load_prompt()` function and in-memory caching
- **Recommendation Engine**: `backend/app/services/recommendation_engine.py` with:
  - `build_user_context()` - Builds comprehensive user context from database
  - `validate_context()` - Validates context structure
  - `generate_recommendations_via_openai()` - Generates recommendations via OpenAI API
  - Error handling with exponential backoff retry logic
  - Token usage tracking (in metadata for review, stripped before DB save)
- **Recommendation Endpoint**: `backend/app/routers/recommendations.py` with:
  - POST `/recommendations/generate/{user_id}` - Full recommendation generation workflow
  - User validation, consent checking, existing recommendations check
  - Context building, OpenAI integration, tone validation
  - Database persistence with metadata (validation_warnings included, token_usage/cost excluded)
  - Status codes: 200 for cached, 201 for newly created
- **Test Scripts**: 
  - `scripts/test_context_builder.py` - Context building tests, all passing
  - `scripts/test_openai_generation.py` - OpenAI integration tests, all quality checks passing
- **Test Results**: All recommendations use empowering language, all quality checks passing, endpoint tested and verified
- **Metadata Design**: Saves metadata (including validation_warnings) but excludes token_usage and estimated_cost_usd (used for logging/review only)
- **Next**: Approval workflow UI components

### Guardrails
- **Status**: âœ… Complete - Guardrails service implemented and tested, integrated into recommendation endpoint and product matching
- **Completed**: Guardrails service with tone validation, consent checking, eligibility validation, partner offer filtering, product eligibility checking, mandatory disclosure
- **Service File**: `backend/app/services/guardrails.py`
- **Functions**:
  - `validate_tone()` - Returns structured warnings (critical/notable) stored in metadata_json
  - `check_consent()` - Checks user consent status
  - `check_income_eligibility()`, `check_credit_eligibility()`, `check_account_exists()` - Eligibility checks
  - `check_product_eligibility()` - Checks product eligibility (income, utilization, existing accounts, category-specific rules) (PR #41)
  - `filter_eligible_products()` - Batch filters product matches by eligibility (PR #41)
  - `filter_partner_offers()` - Filters offers based on eligibility
  - `append_disclosure()` - Appends mandatory disclosure
- **Test Scripts**: 
  - `scripts/test_guardrails.py` - All tests passing
  - `scripts/test_product_eligibility.py` - Comprehensive product eligibility tests (PR #41)
- **Key Design**: All recommendations persisted regardless of warnings - operator reviews and decides
- **Integration**: âœ… Integrated into recommendation generation endpoint (PR #21) and product matching flow (PR #41)

### Infrastructure
- **Status**: Not deployed
- **Next**: Set up AWS SAM template and Lambda configuration
- **Priority**: Day 3 - after MVP features complete

## Known Issues
- âœ… Python version upgraded to 3.11.9 - Resolved
- Frontend lib/ folder gitignore conflict resolved (using backend/lib/ pattern)

## Success Metrics Tracking
- **Coverage**: Target 100% (all consented users have persona + â‰¥3 behaviors)
- **Explainability**: Target 100% (all recommendations have rationales)
- **Latency**: Target <5 seconds per user recommendation generation
  - **Current**: ~17 seconds average with gpt-4o-mini (quality-first approach)
  - **Options**: gpt-3.5-turbo achieves 5.5s (67% faster), Redis caching + async task queue, or hybrid approach
  - **Decision Pending**: Optimizing for quality vs speed trade-offs
- **Auditability**: Target 100% (all recommendations have decision traces)

## Server Concurrency & Performance

### Concurrency Optimizations (PR #26)
- âœ… **Uvicorn Workers**: Running with 4 workers for concurrent request handling
  - Prevents blocking operations (like recommendation generation) from blocking other requests
  - Each worker is a separate process, allowing true parallelism
  - Command: `uvicorn app.main:app --workers 4 --host 0.0.0.0 --port 8000`
- âœ… **SQLite WAL Mode**: Enabled Write-Ahead Logging for concurrent database access
  - Allows multiple readers while a writer is active
  - Prevents user list queries from hanging during recommendation generation
  - Implemented via SQLAlchemy event listener in `backend/app/database.py`
  - Trade-offs documented in DECISIONS.md and LIMITATIONS.md
- âœ… **Issue Resolved**: User list no longer hangs when generating recommendations
  - Combination of 4 workers + WAL mode fixes the blocking issue
  - Verified and working in development

## Next Milestone
**Parquet Export & S3 Integration**: Export user features and evaluation results to Parquet format, upload to S3 with pre-signed URLs

